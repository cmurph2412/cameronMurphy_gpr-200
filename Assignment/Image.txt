
/*
 Author:				Cameron-Murphy
 Class:					GPR-200-01
 Assignment:			Midterm
 Due Date:              10/29/20
*/
// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN

// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)
//    point: input 3D vector
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)
//    point: input 3D vector
vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

//Rotation Matrix on Y Vector, taken from: https://gist.github.com/onedayitwillmake/3288507
mat4 rotationY( in float angle ) {
	return mat4(	cos(angle),		0,		sin(angle),	0,
			 				0,		1.0,			 0,	0,
					-sin(angle),	0,		cos(angle),	0,
							0, 		0,				0,	1);
}

mat4 rotationX( in float angle)
{
    return mat4( 1, 0, 0, 0,
                0, cos(angle), -sin(angle), 0,
                0, sin(angle), cos(angle), 0,
                0, 0, 0, 1);

}

// calcViewport: calculate the viewing plane (viewport) coordinate
//    viewport:       output viewing plane coordinate
//    ndc:            output normalized device coordinate
//    uv:             output screen-space coordinate
//    aspect:         output aspect ratio of screen
//    resolutionInv:  output reciprocal of resolution
//    viewportHeight: input height of viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,
                  out float aspect, out vec2 resolutionInv,
                  in float viewportHeight, in float focalLength,
                  in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f
    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);
}

// calcRay: calculate the ray direction and origin for the current pixel
//    rayDirection: output direction of ray from origin
//    rayOrigin:    output origin point of ray
//    viewport:     input viewing plane coordinate (use above function to calculate)
//    focalLength:  input distance to viewing plane
void calcRay(out vec4 rayDirection, out vec4 rayOrigin,
             in vec3 eyePosition, in vec3 viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = asOffset(viewport - eyePosition);
}

//Sphere struct
struct sSphere
{
    vec4 center;
    float radius;
};

//Initiates sphere object
bool initSphere(out sSphere sphere, in vec3 center, in float radius)
{
    sphere.center = asPoint(center);
    if(radius > 0.0)
    {
    	sphere.radius = radius;
        return true;
    }
    
    sphere.radius = 1.0;
    return false;
}

//Point light struct
struct sPointLight
{
    vec4 center;
    vec4 color;
    float intensity;
};

//Initiates point light object
bool initLight(out sPointLight light, in vec3 center, in vec3 color, in float intensity)
{
	light.center = asPoint(center);
    light.color = asPoint(color);
    light.intensity = intensity;
    return true;
}

//Determines length squared
float lenSq(vec2 x)
{
    return dot(x, x);
}

//Lighting constants
const vec4 specularReflectionColor = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 globalAmbientColor = vec4(1.0, 0.0, 0.0, 1.0);
const float globalLightIntensity = 0.01;

//Calculatings lighting based on point light
void calculateLighting(in sPointLight light, out vec4 colorVariable, in vec3 position, in vec3 normal, in vec3 viewport, in vec4 baseColor)
{
    //Calculating lighting
    vec4 lightVector = normalize(light.center - asPoint(position));
    float pointDistance = distance(asPoint(position), light.center);
    float attenuatedIntensity = 1.0 / (1.0 + pointDistance / light.intensity + (pointDistance * pointDistance) / (light.intensity * light.intensity));
    float diffuseIntensity = max(0.0, dot(lightVector, asPoint(normal)));
        
    //Phong lighting calculations
    float highlightExponent = 20.0;
    float higherExponent = highlightExponent * 4.0;
    vec4 reflectedLightVector = reflect(-lightVector, asPoint(normal));
    vec4 viewVector = normalize(asPoint(viewport) - asPoint(position));
    float specularCoeffecient = max(0.0, dot(viewVector, reflectedLightVector)); 
            
    //Phong
    float specularIntensity = pow(specularCoeffecient, highlightExponent);
            
    //Bling-Phong
    float halfwayVector = dot(asPoint(normal), normalize(lightVector + viewVector));
    //float specularIntensity = pow(halfwayVector, higherExponent); //BLINN-PHONG
            
    //Adds value to the color variable
    colorVariable += (diffuseIntensity * baseColor + specularIntensity * specularReflectionColor) * light.color;
}

vec4 calcSphere(in vec4 rayDirection, in sSphere sphere, in sPointLight light, in vec3 viewport)
{
    vec3 dp;
    dp.xy = rayDirection.xy - sphere.center.xy;
    float lSq = lenSq(dp.xy);
    float rSq = sphere.radius * sphere.radius; 
    
    if(lSq <= rSq)
    {
        //Calculating sphere attributes
        dp.z = rSq - lSq;
        vec3 position = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));
        vec3 normal = (position - sphere.center.xyz) / sphere.radius;
        vec4 point = vec4(normal * 0.5 + 0.5, 1.0); //Calculating color based on normal
        //vec4 point = vec4(0.5 * (rec.normal + vec3(1.0, 1.0, 1.0)), 1.0);
        vec4 baseColor = texture(iChannel0, point.xy);
        
       	 //Variable stores sum of all diffuse and specular reflections of all lights
        vec4 colorVariable;
        
        //Calculates lighting for both point lights
        calculateLighting(light, colorVariable, position, normal, viewport, baseColor);
        //calculateLighting(lights[1], colorVariable, position, normal, viewport, baseColor);
            
        return globalLightIntensity * globalAmbientColor + colorVariable;
    }
    
    return vec4(-1.0, -1.0, -1.0, 0.0);
}


// calcColor: calculate the color of a pixel given a ray
//    rayDirection: input ray direction
//    rayOrigin:    input ray origin
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin, in vec3 viewport)
{
    // SCENE
    
    sSphere spheres[2];
    
    // Instantiate Sphere
    //sSphere spheres[0];
    initSphere(spheres[0], vec3(0.0, 0.0, -4.0), 0.5);
    
    //sSphere spheres[1];
    initSphere(spheres[1], vec3(sin(iTime + 3.14/2.0), 0.0, sin(iTime) - 4.0), 0.25);
    
    // Instantiate Lights
    sPointLight lights[2];
    initLight(lights[0], vec3(0.75, sin(iTime * 2.0) * 2.0, -1.5), vec3(0.75, 0.75, 1.0), 5.0);
    //initLight(lights[1], vec3(-3.0, -3.0, -1.5), vec3(1.0, 0.5, 0.5), 4.0);
    
    if(spheres[0].center.z > spheres[1].center.z)
    {
        vec4 color = calcSphere(rayDirection, spheres[1], lights[0], viewport);
        if(color != vec4(-1.0, -1.0, -1.0, 0.0))
        {
            return color;
        }
        
        color = calcSphere(rayDirection, spheres[0], lights[0], viewport);
        if(color != vec4(-1.0, -1.0, -1.0, 0.0))
        {
            return color;
        }
    }
    else
    {
        vec4 color = calcSphere(rayDirection, spheres[0], lights[0], viewport);
        if(color != vec4(-1.0, -1.0, -1.0, 0.0))
        {
            return color;
        }
        
        color = calcSphere(rayDirection, spheres[1], lights[0], viewport);
        if(color != vec4(-1.0, -1.0, -1.0, 0.0))
        {
            return color;
        }
    }
	
	// Blue orange gradient background
	//const vec3 warm = vec3(0.8, 0.4, 0.2), cool = vec3(0.2, 0.4, 0.8);
	//return vec4(mix(warm, cool, rayDirection.y), 1.0);
    
    // Basic gray background
    rayDirection = rayDirection * rotationY(iMouse.x / 100.0); //Rotate ray direction based on Mouse
    //rayDirection = rayDirection * rotationX(iMouse.y / 100.0) + 0.5; //Rotate ray direction based on Mouse
    return texture(iChannel1, rayDirection.xyz);
}

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info
    vec3 viewport;
    vec2 ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;
    
    

    // setup
    fragColor = vec4(0.0);
    
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
    	             viewportHeight, focalLength,
    	             fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);
    
    fragColor += calcColor(rayDirection, rayOrigin, viewport);
}