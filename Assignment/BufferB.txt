/*
 Author:				Cameron-Murphy
 Class:					GPR-200-01
 Assignment:			Midterm
 Due Date:              10/29/20
*/

//CREATES CUBEMAP AND BOX

//Structure for square object
struct sSquare
{
    vec2 origin;
    float height;
    float width;
};

//Initializes variables for the square object
void initSquare(out sSquare square, in vec2 origin, in float height, in float width)
{
    square.origin = origin;
    square.height = height;
    square.width = width;
}

//Rotate around cube map dependent on ray
color4 cubeMap(in sRay ray, in samplerCube channel2)
{
    return texture(channel2, ray.direction.xyz); //Returns calculated texture
}

//Determines if the square is hit
bool hitSquare(sSquare square, sCoord loc)
{
    if(square.origin.x - square.width / 2.0 < loc.x && loc.x < square.origin.x + square.width / 2.0) //Checks if coord is within the width
    {
        return square.origin.y - square.height / 2.0 < loc.y && loc.y < square.origin.y + square.height / 2.0; //Checks if coord is within the height
    }
}

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    //Determining location of pixel
    sCoord px = vp.pixelCoord;
    sDCoord res = iChannelResolution[0].xy;
    sScalar ratio = res.y * vp.resolutionInv.y / 1.0;
    sCoord loc = px / res;
    loc = ratio * loc;// + iTime; // zoom + shift
    
    //Rotates the ray with mouse pos
    ray.direction = ray.direction * rotationY(iMouse.x * 0.01);
    
    //Square Variables
    float width = 0.5 - iMouse.y * 0.001;
    float height = width * 1.5;
    
    //Initializes square location
    sSquare square;
    initSquare(square, vec2(0.5, 0.5), height, width);
    
    //Determines top left pixel of square (used to calculate the texture)
    vec2 topLeft = vec2(square.origin.x - square.width / 2.0, square.origin.y - square.height / 2.0);
    
    //If square is hit returns specified channel
    if(hitSquare(square, loc))
    {
        //Calculate loc with relation to position in square
        loc.x = (loc.x - topLeft.x) / width * 0.6;
        loc.y = (loc.y - topLeft.y) / height;
        return texture(iChannel0, loc); //returns texture (buffer C)
    }
    
    //If square is not hit returns cubemap
    return cubeMap(ray, iChannel1);
}

//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    fragColor += calcColor(vp, ray);
}